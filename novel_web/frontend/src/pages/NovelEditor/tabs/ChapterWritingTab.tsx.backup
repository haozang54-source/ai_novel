import { useEffect, useState, useRef } from 'react';
import { 
  Card, 
  List, 
  Button, 
  Space, 
  Typography, 
  Input, 
  message, 
  Spin,
  Tag,
  Divider,
  Row,
  Col,
  Modal,
  Form,
  Popconfirm,
  Tree
} from 'antd';
import { 
  EditOutlined, 
  SaveOutlined, 
  RobotOutlined,
  FileTextOutlined,
  PlusOutlined,
  DeleteOutlined,
  FolderOutlined,
  FileOutlined
} from '@ant-design/icons';
import type { TreeDataNode } from 'antd';
import axios from 'axios';
import { chapterApi } from '../../../services/api';
import { useOutlineStore } from '../../../store/outlineStore';
import AIAssistantPanel from '../../../components/AIAssistantPanel';

const { Title, Text, Paragraph } = Typography;
const { TextArea } = Input;

interface Chapter {
  id?: number;
  outline_chapter_id: number;
  content: string;
  word_count: number;
  status: string;
}

interface ChapterInfo {
  outline_chapter_id: number;
  chapter_num: number;
  title: string;
  summary: string;
  chapter: Chapter | null;
}

interface ProjectChaptersResponse {
  message: string;
  outline_level: 'chapter' | 'volume' | null;
  chapters: ChapterInfo[];
  volumes?: Array<{
    outline_chapter_id: number;
    volume_num: number;
    title: string;
    summary: string;
  }>;
}

interface VolumeTreeNode {
  volume_num: number;
  title: string;
  children: ChapterInfo[];
}

interface ChapterWritingTabProps {
  projectId: number;
}

/**
 * ç« èŠ‚ç¼–å†™Tab - ä¸“æ³¨äºæ­£æ–‡åˆ›ä½œ
 */
export default function ChapterWritingTab({ projectId }: ChapterWritingTabProps) {
  const [chapters, setChapters] = useState<ChapterInfo[]>([]);
  const [volumeTree, setVolumeTree] = useState<VolumeTreeNode[]>([]);
  const [outlineLevel, setOutlineLevel] = useState<'chapter' | 'volume' | null>(null);
  const [responseMessage, setResponseMessage] = useState('');
  const [selectedChapter, setSelectedChapter] = useState<ChapterInfo | null>(null);
  const [content, setContent] = useState('');
  const [loading, setLoading] = useState(false);
  const [saving, setSaving] = useState(false);
  
  // AIåŠ©æ‰‹ç›¸å…³çŠ¶æ€
  const [aiPanelVisible, setAiPanelVisible] = useState(false);
  const [selectedText, setSelectedText] = useState('');
  const [selectionRange, setSelectionRange] = useState<{ start: number; end: number } | null>(null);
  const textAreaRef = useRef<any>(null);
  const hasLoadedRef = useRef(false);
  const loadedProjectIdRef = useRef<number | null>(null);
  
  // ç« èŠ‚ç®¡ç†ç›¸å…³çŠ¶æ€
  const [isAddModalVisible, setIsAddModalVisible] = useState(false);
  const [isEditChapterModalVisible, setIsEditChapterModalVisible] = useState(false);
  const [editingChapterInfo, setEditingChapterInfo] = useState<ChapterInfo | null>(null);
  const [addForm] = Form.useForm();
  const [editForm] = Form.useForm();
  
  const { outline } = useOutlineStore();

  useEffect(() => {
    // é˜²æ­¢ React StrictMode å¯¼è‡´çš„é‡å¤è°ƒç”¨
    if (hasLoadedRef.current && loadedProjectIdRef.current === projectId) {
      return;
    }
    
    hasLoadedRef.current = true;
    loadedProjectIdRef.current = projectId;
    loadChapters();
  }, [projectId]);

  const loadChapters = async () => {
    setLoading(true);
    try {
      const response = await axios.get<ProjectChaptersResponse>(`/api/chapters/project/${projectId}`);
      const data = response.data;
      
      setOutlineLevel(data.outline_level);
      setResponseMessage(data.message);
      setChapters(data.chapters || []);
      
      // å¦‚æœæ˜¯å·çº§å¤§çº²ï¼Œæ„å»ºæ ‘å½¢ç»“æ„
      if (data.outline_level === 'volume' && data.chapters.length > 0) {
        // è·å–å¤§çº²æ•°æ®æ¥æ„å»ºå®Œæ•´çš„å·ç»“æ„
        const outlineResponse = await axios.get(`/api/projects/${projectId}/outline?hierarchy=true`);
        const outline = outlineResponse.data;
        
        // æ„å»ºå·-ç« èŠ‚æ ‘
        const tree: VolumeTreeNode[] = outline.chapters.map((vol: any) => ({
          volume_num: vol.chapter_num,
          title: vol.title,
          children: data.chapters.filter((ch: ChapterInfo) => ch.parent_id === vol.id)
        }));
        
        setVolumeTree(tree);
      } else {
        setVolumeTree([]);
      }
      
      if (data.outline_level === 'volume' && data.chapters.length === 0) {
        message.warning(data.message);
      }
    } catch (error) {
      message.error('åŠ è½½ç« èŠ‚åˆ—è¡¨å¤±è´¥');
    } finally {
      setLoading(false);
    }
  };

  const handleSelectChapter = (chapterInfo: ChapterInfo) => {
    setSelectedChapter(chapterInfo);
    setContent(chapterInfo.chapter?.content || '');
  };

  const handleSave = async () => {
    if (!selectedChapter) return;

    setSaving(true);
    try {
      await axios.post(`/api/chapters/outline-chapter/${selectedChapter.outline_chapter_id}`, {
        content,
        status: 'draft'
      });
      message.success('ä¿å­˜æˆåŠŸ');
      loadChapters();
    } catch (error) {
      message.error('ä¿å­˜å¤±è´¥');
    } finally {
      setSaving(false);
    }
  };

  // å¤„ç†æ–‡æœ¬é€‰æ‹©
  const handleTextSelect = () => {
    if (!textAreaRef.current) return;

    const textarea = textAreaRef.current.resizableTextArea.textArea;
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;

    if (start !== end) {
      const selected = content.substring(start, end);
      setSelectedText(selected);
      setSelectionRange({ start, end });
    }
  };

  // æ‰“å¼€AIåŠ©æ‰‹
  const handleOpenAI = () => {
    if (!selectedText) {
      message.warning('è¯·å…ˆé€‰ä¸­è¦ä¿®æ”¹çš„æ–‡æœ¬');
      return;
    }
    setAiPanelVisible(true);
  };

  // åº”ç”¨AIä¿®æ”¹
  const handleApplyAI = (newText: string) => {
    if (!selectionRange) return;

    const before = content.substring(0, selectionRange.start);
    const after = content.substring(selectionRange.end);
    const updatedContent = before + newText + after;
    
    setContent(updatedContent);
    setSelectedText('');
    setSelectionRange(null);
  };

  // å–æ¶ˆAIä¿®æ”¹
  const handleCancelAI = () => {
    setSelectedText('');
    setSelectionRange(null);
  };

  const getContextText = () => {
    if (!selectionRange) return { before: '', after: '' };
    
    const before = content.substring(
      Math.max(0, selectionRange.start - 200), 
      selectionRange.start
    );
    const after = content.substring(
      selectionRange.end, 
      Math.min(content.length, selectionRange.end + 200)
    );
    
    return { before, after };
  };

  const getStatusTag = (status: string) => {
    const statusMap: Record<string, { color: string; text: string }> = {
      'not_started': { color: 'default', text: 'æœªå¼€å§‹' },
      'draft': { color: 'processing', text: 'è‰ç¨¿' },
      'reviewing': { color: 'warning', text: 'å®¡é˜…ä¸­' },
      'completed': { color: 'success', text: 'å·²å®Œæˆ' }
    };
    const s = statusMap[status] || statusMap['not_started'];
    return <Tag color={s.color}>{s.text}</Tag>;
  };

  // æ–°å¢ç« èŠ‚
  const handleAddChapter = async (values: any) => {
    if (!outline?.id) {
      message.error('æœªæ‰¾åˆ°å¤§çº²ä¿¡æ¯');
      return;
    }

    try {
      await chapterApi.addOutlineChapter(outline.id, values);
      message.success('ç« èŠ‚æ·»åŠ æˆåŠŸ');
      setIsAddModalVisible(false);
      addForm.resetFields();
      loadChapters();
    } catch (error) {
      message.error('æ·»åŠ ç« èŠ‚å¤±è´¥');
    }
  };

  // ç¼–è¾‘ç« èŠ‚ä¿¡æ¯
  const handleEditChapterInfo = (chapterInfo: ChapterInfo) => {
    setEditingChapterInfo(chapterInfo);
    editForm.setFieldsValue({
      title: chapterInfo.title,
      summary: chapterInfo.summary,
    });
    setIsEditChapterModalVisible(true);
  };

  // ä¿å­˜ç« èŠ‚ä¿¡æ¯ç¼–è¾‘
  const handleSaveChapterInfo = async (values: any) => {
    if (!editingChapterInfo) return;

    try {
      await chapterApi.updateOutlineChapter(editingChapterInfo.outline_chapter_id, values);
      message.success('ç« èŠ‚ä¿¡æ¯æ›´æ–°æˆåŠŸ');
      setIsEditChapterModalVisible(false);
      setEditingChapterInfo(null);
      editForm.resetFields();
      loadChapters();
    } catch (error) {
      message.error('æ›´æ–°å¤±è´¥');
    }
  };

  // åˆ é™¤ç« èŠ‚
  const handleDeleteChapter = async (outlineChapterId: number) => {
    try {
      await chapterApi.deleteOutlineChapter(outlineChapterId);
      message.success('ç« èŠ‚åˆ é™¤æˆåŠŸ');
      if (selectedChapter?.outline_chapter_id === outlineChapterId) {
        setSelectedChapter(null);
        setContent('');
      }
      loadChapters();
    } catch (error) {
      message.error('åˆ é™¤å¤±è´¥');
    }
  };

  return (
    <Row gutter={16} style={{ height: 'calc(100vh - 200px)' }}>
      {/* å·¦ä¾§ç« èŠ‚åˆ—è¡¨ */}
      <Col span={6}>
        <Card 
          title="ç« èŠ‚åˆ—è¡¨"
          extra={
            outlineLevel === 'chapter' && (
              <Button 
                type="primary" 
                size="small" 
                icon={<PlusOutlined />}
                onClick={() => setIsAddModalVisible(true)}
              >
                æ–°å¢
              </Button>
            )
          }
          style={{ height: '100%', overflowY: 'auto' }}
          bodyStyle={{ padding: 0 }}
        >
          {loading ? (
            <div style={{ textAlign: 'center', padding: 40 }}>
              <Spin />
            </div>
          ) : outlineLevel === 'volume' ? (
            <div style={{ padding: 24, textAlign: 'center' }}>
              <Text type="secondary">
                {responseMessage}
              </Text>
              <Divider />
              <Text type="secondary" style={{ fontSize: 12 }}>
                ğŸ’¡ æç¤ºï¼šè¯·å…ˆåœ¨"å¤§çº²ç¼–è¾‘"Tabä¸­å°†å·çº§å¤§çº²ç»†åŒ–ä¸ºç« èŠ‚å¤§çº²ï¼Œ<br/>
                æˆ–é‡æ–°ç”Ÿæˆç« çº§å¤§çº²åå†è¿›è¡Œæ­£æ–‡ç¼–å†™ã€‚
              </Text>
            </div>
          ) : chapters.length === 0 ? (
            <div style={{ padding: 24, textAlign: 'center' }}>
              <Text type="secondary">
                æš‚æ— ç« èŠ‚ï¼Œè¯·å…ˆåœ¨"å¤§çº²ç¼–è¾‘"Tabä¸­ç”Ÿæˆå¤§çº²
              </Text>
            </div>
          ) : (
            <List
              dataSource={chapters}
              renderItem={(item) => (
                <List.Item
                  style={{ 
                    cursor: 'pointer',
                    background: selectedChapter?.outline_chapter_id === item.outline_chapter_id 
                      ? '#e6f7ff' 
                      : 'transparent',
                    padding: '12px 16px'
                  }}
                  onClick={() => handleSelectChapter(item)}
                  actions={[
                    <Button
                      type="text"
                      size="small"
                      icon={<EditOutlined />}
                      onClick={(e) => {
                        e.stopPropagation();
                        handleEditChapterInfo(item);
                      }}
                    />,
                    <Popconfirm
                      title="ç¡®å®šåˆ é™¤æ­¤ç« èŠ‚ï¼Ÿ"
                      description="åˆ é™¤åå°†æ— æ³•æ¢å¤ï¼ŒåŒ…æ‹¬å·²ç¼–å†™çš„æ­£æ–‡å†…å®¹"
                      onConfirm={(e) => {
                        e?.stopPropagation();
                        handleDeleteChapter(item.outline_chapter_id);
                      }}
                      onCancel={(e) => e?.stopPropagation()}
                      okText="åˆ é™¤"
                      cancelText="å–æ¶ˆ"
                    >
                      <Button
                        type="text"
                        size="small"
                        danger
                        icon={<DeleteOutlined />}
                        onClick={(e) => e.stopPropagation()}
                      />
                    </Popconfirm>
                  ]}
                >
                  <List.Item.Meta
                    title={
                      <Space>
                        <Text strong>ç¬¬{item.chapter_num}ç« </Text>
                        {getStatusTag(item.chapter?.status || 'not_started')}
                      </Space>
                    }
                    description={
                      <div>
                        <Paragraph ellipsis={{ rows: 1 }} style={{ margin: 0 }}>
                          {item.title}
                        </Paragraph>
                        {item.chapter && (
                          <Text type="secondary" style={{ fontSize: 12 }}>
                            {item.chapter.word_count} å­—
                          </Text>
                        )}
                      </div>
                    }
                  />
                </List.Item>
              )}
            />
          )}
        </Card>
      </Col>

      {/* å³ä¾§ç¼–è¾‘å™¨ */}
      <Col span={18}>
        <Card
          title={
            selectedChapter ? (
              <Space>
                <FileTextOutlined />
                <span>ç¬¬{selectedChapter.chapter_num}ç« ï¼š{selectedChapter.title}</span>
              </Space>
            ) : (
              'è¯·é€‰æ‹©ç« èŠ‚'
            )
          }
          extra={
            selectedChapter && (
              <Space>
                <Button
                  type="primary"
                  icon={<RobotOutlined />}
                  onClick={handleOpenAI}
                  disabled={!selectedText}
                >
                  AIåŠ©æ‰‹
                </Button>
                <Button
                  type="primary"
                  icon={<SaveOutlined />}
                  onClick={handleSave}
                  loading={saving}
                >
                  ä¿å­˜
                </Button>
              </Space>
            )
          }
          style={{ height: '100%' }}
          bodyStyle={{ 
            height: 'calc(100% - 64px)', 
            display: 'flex', 
            flexDirection: 'column' 
          }}
        >
          {selectedChapter ? (
            <>
              {/* ç« èŠ‚å¤§çº²æ‘˜è¦ */}
              <Card 
                size="small" 
                style={{ marginBottom: 16, background: '#fafafa' }}
                title="å¤§çº²æ‘˜è¦"
              >
                <Paragraph style={{ margin: 0 }}>
                  {selectedChapter.summary || 'æš‚æ— å¤§çº²'}
                </Paragraph>
              </Card>

              <Divider style={{ margin: '0 0 16px 0' }} />

              {/* æç¤ºä¿¡æ¯ */}
              <div style={{ marginBottom: 12 }}>
                <Text type="secondary">
                  ğŸ’¡ é€‰ä¸­ä»»æ„æ–‡æœ¬åï¼Œç‚¹å‡»"AIåŠ©æ‰‹"æŒ‰é’®ï¼Œå³å¯ä¸AIäº¤äº’è¿›è¡Œä¿®æ”¹
                </Text>
                {selectedText && (
                  <Text type="success" style={{ marginLeft: 16 }}>
                    âœ“ å·²é€‰ä¸­ {selectedText.length} ä¸ªå­—ç¬¦
                  </Text>
                )}
              </div>

              {/* æ–‡æœ¬ç¼–è¾‘å™¨ */}
              <TextArea
                ref={textAreaRef}
                value={content}
                onChange={(e) => setContent(e.target.value)}
                onSelect={handleTextSelect}
                placeholder="å¼€å§‹å†™ä½œ..."
                style={{ 
                  flex: 1,
                  fontFamily: 'serif',
                  fontSize: 16,
                  lineHeight: 1.8,
                  resize: 'none'
                }}
              />

              {/* ç»Ÿè®¡ä¿¡æ¯ */}
              <div style={{ marginTop: 12, textAlign: 'right' }}>
                <Space split={<Divider type="vertical" />}>
                  <Text type="secondary">
                    å­—æ•°: {content.replace(/\s/g, '').length}
                  </Text>
                  <Text type="secondary">
                    æ®µè½: {content.split('\n\n').filter(p => p.trim()).length}
                  </Text>
                </Space>
              </div>
            </>
          ) : (
            <div style={{ 
              flex: 1, 
              display: 'flex', 
              alignItems: 'center', 
              justifyContent: 'center',
              color: '#999'
            }}>
              <Space direction="vertical" align="center">
                <FileTextOutlined style={{ fontSize: 48 }} />
                <Text type="secondary">è¯·ä»å·¦ä¾§é€‰æ‹©è¦ç¼–è¾‘çš„ç« èŠ‚</Text>
              </Space>
            </div>
          )}
        </Card>
      </Col>

      {/* AIåŠ©æ‰‹é¢æ¿ */}
      <AIAssistantPanel
        visible={aiPanelVisible}
        onClose={() => setAiPanelVisible(false)}
        projectId={projectId}
        selectedText={selectedText}
        contextBefore={getContextText().before}
        contextAfter={getContextText().after}
        chapterId={selectedChapter?.chapter?.id}
        onApply={handleApplyAI}
        onCancel={handleCancelAI}
      />

      {/* æ–°å¢ç« èŠ‚æ¨¡æ€æ¡† */}
      <Modal
        title="æ–°å¢ç« èŠ‚"
        open={isAddModalVisible}
        onCancel={() => {
          setIsAddModalVisible(false);
          addForm.resetFields();
        }}
        onOk={() => addForm.submit()}
        okText="æ·»åŠ "
        cancelText="å–æ¶ˆ"
      >
        <Form
          form={addForm}
          layout="vertical"
          onFinish={handleAddChapter}
        >
          <Form.Item
            label="ç« èŠ‚æ ‡é¢˜"
            name="title"
            rules={[{ required: true, message: 'è¯·è¾“å…¥ç« èŠ‚æ ‡é¢˜' }]}
          >
            <Input placeholder="ä¾‹å¦‚ï¼šåˆå…¥æ±Ÿæ¹–" />
          </Form.Item>
          <Form.Item
            label="ç« èŠ‚æ‘˜è¦"
            name="summary"
          >
            <Input.TextArea 
              rows={4} 
              placeholder="ç®€è¦æè¿°æœ¬ç« çš„ä¸»è¦å†…å®¹ã€å†²çªå’Œæƒ…èŠ‚å‘å±•..." 
            />
          </Form.Item>
          <Form.Item
            label="æ ¸å¿ƒå†²çª"
            name="conflicts"
          >
            <Input.TextArea rows={2} placeholder="æœ¬ç« çš„ä¸»è¦çŸ›ç›¾å’Œå†²çª..." />
          </Form.Item>
          <Form.Item
            label="æƒ…æ„ŸåŸºè°ƒ"
            name="emotional_beat"
          >
            <Input placeholder="ä¾‹å¦‚ï¼šç´§å¼ ã€æ¿€åŠ¨ã€æ‚²ä¼¤..." />
          </Form.Item>
        </Form>
      </Modal>

      {/* ç¼–è¾‘ç« èŠ‚ä¿¡æ¯æ¨¡æ€æ¡† */}
      <Modal
        title="ç¼–è¾‘ç« èŠ‚ä¿¡æ¯"
        open={isEditChapterModalVisible}
        onCancel={() => {
          setIsEditChapterModalVisible(false);
          setEditingChapterInfo(null);
          editForm.resetFields();
        }}
        onOk={() => editForm.submit()}
        okText="ä¿å­˜"
        cancelText="å–æ¶ˆ"
      >
        <Form
          form={editForm}
          layout="vertical"
          onFinish={handleSaveChapterInfo}
        >
          <Form.Item
            label="ç« èŠ‚æ ‡é¢˜"
            name="title"
            rules={[{ required: true, message: 'è¯·è¾“å…¥ç« èŠ‚æ ‡é¢˜' }]}
          >
            <Input />
          </Form.Item>
          <Form.Item
            label="ç« èŠ‚æ‘˜è¦"
            name="summary"
          >
            <Input.TextArea rows={4} />
          </Form.Item>
          <Form.Item
            label="æ ¸å¿ƒå†²çª"
            name="conflicts"
          >
            <Input.TextArea rows={2} />
          </Form.Item>
          <Form.Item
            label="æƒ…æ„ŸåŸºè°ƒ"
            name="emotional_beat"
          >
            <Input />
          </Form.Item>
        </Form>
      </Modal>
    </Row>
  );
}
